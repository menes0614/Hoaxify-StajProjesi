{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport axios from 'axios';\nexport const useApiProgress = (apiMethod, apiPath, strictPath) => {\n  const [pendingApiCall, setPendingApiCall] = useState(false);\n  useEffect(() => {\n    let requestInterceptor, responseInterceptor;\n\n    const updateApiCallFor = (method, url, inProgress) => {\n      if (method !== apiMethod) {\n        return;\n      }\n\n      if (strictPath && url === apiPath) {\n        setPendingApiCall(inProgress);\n      } else if (!strictPath && url.startsWith(apiPath)) {\n        setPendingApiCall(inProgress);\n      }\n    };\n\n    const registerInterceptors = () => {\n      requestInterceptor = axios.interceptors.request.use(request => {\n        const {\n          url,\n          method\n        } = request;\n        updateApiCallFor(method, url, true);\n        return request;\n      });\n      responseInterceptor = axios.interceptors.response.use(response => {\n        const {\n          url,\n          method\n        } = response.config;\n        updateApiCallFor(method, url, false);\n        return response;\n      }, error => {\n        const {\n          url,\n          method\n        } = error.config;\n        updateApiCallFor(method, url, false);\n        throw error;\n      });\n    };\n\n    const unregisterInterceptors = () => {\n      axios.interceptors.request.eject(requestInterceptor);\n      axios.interceptors.response.eject(responseInterceptor);\n    };\n\n    registerInterceptors();\n    return function unmount() {\n      unregisterInterceptors();\n    };\n  }, [apiPath, apiMethod, strictPath]);\n  return pendingApiCall;\n};","map":{"version":3,"sources":["C:/Users/Enes/frontend/src/shared/ApiProgress.js"],"names":["useState","useEffect","axios","useApiProgress","apiMethod","apiPath","strictPath","pendingApiCall","setPendingApiCall","requestInterceptor","responseInterceptor","updateApiCallFor","method","url","inProgress","startsWith","registerInterceptors","interceptors","request","use","response","config","error","unregisterInterceptors","eject","unmount"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,OAAOC,KAAP,MAAkB,OAAlB;AAEA,OAAO,MAAMC,cAAc,GAAG,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,UAArB,KAAoC;AAChE,QAAM,CAACC,cAAD,EAAiBC,iBAAjB,IAAsCR,QAAQ,CAAC,KAAD,CAApD;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIQ,kBAAJ,EAAwBC,mBAAxB;;AAEA,UAAMC,gBAAgB,GAAG,CAACC,MAAD,EAASC,GAAT,EAAcC,UAAd,KAA6B;AACpD,UAAIF,MAAM,KAAKR,SAAf,EAA0B;AACxB;AACD;;AACD,UAAIE,UAAU,IAAIO,GAAG,KAAKR,OAA1B,EAAmC;AACjCG,QAAAA,iBAAiB,CAACM,UAAD,CAAjB;AACD,OAFD,MAEO,IAAI,CAACR,UAAD,IAAeO,GAAG,CAACE,UAAJ,CAAeV,OAAf,CAAnB,EAA4C;AACjDG,QAAAA,iBAAiB,CAACM,UAAD,CAAjB;AACD;AACF,KATD;;AAWA,UAAME,oBAAoB,GAAG,MAAM;AACjCP,MAAAA,kBAAkB,GAAGP,KAAK,CAACe,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CAA+BD,OAAO,IAAI;AAC7D,cAAM;AAAEL,UAAAA,GAAF;AAAOD,UAAAA;AAAP,YAAkBM,OAAxB;AACAP,QAAAA,gBAAgB,CAACC,MAAD,EAASC,GAAT,EAAc,IAAd,CAAhB;AACA,eAAOK,OAAP;AACD,OAJoB,CAArB;AAMAR,MAAAA,mBAAmB,GAAGR,KAAK,CAACe,YAAN,CAAmBG,QAAnB,CAA4BD,GAA5B,CACpBC,QAAQ,IAAI;AACV,cAAM;AAAEP,UAAAA,GAAF;AAAOD,UAAAA;AAAP,YAAkBQ,QAAQ,CAACC,MAAjC;AACAV,QAAAA,gBAAgB,CAACC,MAAD,EAASC,GAAT,EAAc,KAAd,CAAhB;AACA,eAAOO,QAAP;AACD,OALmB,EAMpBE,KAAK,IAAI;AACP,cAAM;AAAET,UAAAA,GAAF;AAAOD,UAAAA;AAAP,YAAkBU,KAAK,CAACD,MAA9B;AACAV,QAAAA,gBAAgB,CAACC,MAAD,EAASC,GAAT,EAAc,KAAd,CAAhB;AACA,cAAMS,KAAN;AACD,OAVmB,CAAtB;AAYD,KAnBD;;AAqBA,UAAMC,sBAAsB,GAAG,MAAM;AACnCrB,MAAAA,KAAK,CAACe,YAAN,CAAmBC,OAAnB,CAA2BM,KAA3B,CAAiCf,kBAAjC;AACAP,MAAAA,KAAK,CAACe,YAAN,CAAmBG,QAAnB,CAA4BI,KAA5B,CAAkCd,mBAAlC;AACD,KAHD;;AAKAM,IAAAA,oBAAoB;AAEpB,WAAO,SAASS,OAAT,GAAmB;AACxBF,MAAAA,sBAAsB;AACvB,KAFD;AAGD,GA7CQ,EA6CN,CAAClB,OAAD,EAAUD,SAAV,EAAqBE,UAArB,CA7CM,CAAT;AA+CA,SAAOC,cAAP;AACD,CAnDM","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport axios from 'axios';\r\n\r\nexport const useApiProgress = (apiMethod, apiPath, strictPath) => {\r\n  const [pendingApiCall, setPendingApiCall] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let requestInterceptor, responseInterceptor;\r\n\r\n    const updateApiCallFor = (method, url, inProgress) => {\r\n      if (method !== apiMethod) {\r\n        return;\r\n      }\r\n      if (strictPath && url === apiPath) {\r\n        setPendingApiCall(inProgress);\r\n      } else if (!strictPath && url.startsWith(apiPath)) {\r\n        setPendingApiCall(inProgress);\r\n      }\r\n    };\r\n\r\n    const registerInterceptors = () => {\r\n      requestInterceptor = axios.interceptors.request.use(request => {\r\n        const { url, method } = request;\r\n        updateApiCallFor(method, url, true);\r\n        return request;\r\n      });\r\n\r\n      responseInterceptor = axios.interceptors.response.use(\r\n        response => {\r\n          const { url, method } = response.config;\r\n          updateApiCallFor(method, url, false);\r\n          return response;\r\n        },\r\n        error => {\r\n          const { url, method } = error.config;\r\n          updateApiCallFor(method, url, false);\r\n          throw error;\r\n        }\r\n      );\r\n    };\r\n\r\n    const unregisterInterceptors = () => {\r\n      axios.interceptors.request.eject(requestInterceptor);\r\n      axios.interceptors.response.eject(responseInterceptor);\r\n    };\r\n\r\n    registerInterceptors();\r\n\r\n    return function unmount() {\r\n      unregisterInterceptors();\r\n    };\r\n  }, [apiPath, apiMethod, strictPath]);\r\n\r\n  return pendingApiCall;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}